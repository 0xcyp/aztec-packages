{
  "name": "SchnorrSingleKeyAccount",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/9Xc12/aUBzFcUKTdO/svfewsQ02XWm6994roYHu3f7/5SggRXnN4eF7JQv8Yp2PAPuO3+VfLper5LZbW/3I14/2xvvmeceu887G+52teb7WeI2CYhxXS4VqGIWbQSGrpEkQJ5ViGqZhkiZbhTSKqmmclrJKVgqyMI6qYS3Jolqw3Xp2XCvYY2tlzl5Izj5Izn5IzgFIzkFIziFIzmFIzhFIzlFIzjFIznFIzglIzklIzilIzmlIzhlIzllIzjlIznlIzgVIzkVIziVIzmVIzhVIzlVIzgCSM4TkLEByRpCcMSRnAslZhOQsQXKmkJwZJGe5RTnzu3IGe2thm9F8BmLOG81nIeZ9RvM5iLndaD4PMXcYzRcg5k6jeQ1i7jGaL0LMvUbzOsTcZzRfgpj7jebLEPOA0XwFYh40mq9CzENG8zWIedhovg4xjxjNNyDmUaP5JsQ8ZjTfgpjHjebbEPOE0XwHYp40mu9CzFNG8z2Iedpovg8xzxjNDyDmWaP5IcQ8ZzQ/gpjnjebHEPOC0fwEYl40mp9CzEtG8zOIedlofg4xrxjNLyDmVaP5JcQcGM2vIObQaH4NMReM5jcQc2Q0v4WYY6P5HcScGM0bEHPRaN6EmEtGcwViTo3m9xBzZjRvQcxlo7kKMe83mmsQ8wGj+QPEfNBo/ggxHzKaP0HMh43mzxDzEaP5C8R81Gj+CjEfM5q/QczHjebvEPMJo/kHxHzSaP4JMZ8ymn9BzKeN5t8Qc5fR/Adi7jaa/7bA3N14bf5fn/ZGaa+Q9s5oL4nGhRonadygfrT6lepnqd+h57CeS7pP676l37G+112N65Yb19ZeOO0N014p7R1q7qXRXov1+qFafNWmq1Zbtcuq5VVtq2o9VfuoWkDVxqlWTLVTqiVSbY1qTVR7oVoErc1rrVprt1rL1Nqe1rq09qO1EK0NaK5cc8eaS92oH5pr09yT5mI0N6GxusauGstpbKO+vvq+6guqb6S+gp6depbo3qp7jX57+i7qs/kPVgMtpSBRAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "owner",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "partial_address",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "// Account contract that uses Schnorr signatures for authentication. The signing key is the same as the\n// encryption key, and as such is not stored in the contract but part of the address preimage, so it can\n// be verified by passing in the partial address.\ncontract SchnorrSingleKeyAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::private_call_stack_item::PrivateCallStackItem;\n    use dep::aztec::public_call_stack_item::PublicCallStackItem;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    fn entrypoint(\n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        owner: pub [u8;64], // pubkey x and y coordinates concatenated\n        signature: pub [u8;64], // schnorr signature of the payload hash\n        partial_address: pub Field,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Initialize context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64 + 64 + 1\n        let mut args: BoundedVec<Field, 142> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in owner { args.push(byte as Field); }\n        for byte in signature { args.push(byte as Field); }\n        args.push(partial_address);\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Verify payload signature\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n\n        // Convert owner pubkey into fields\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n        for i in 0..32 {\n          let bytex: Field = owner[31 - i] as Field;\n          x = x + (bytex * mul);\n          let bytey: Field = owner[63 - i] as Field;\n          y = y + (bytey * mul);\n          mul *= 256;\n        }\n        \n        // Verify signature of the payload hash\n        // TODO: Find out why this signature verification never fails\n        let verification = std::schnorr::verify_signature(x, y, signature, message_bytes);\n        assert(verification == true);\n\n        // Verify public key against address\n        let reproduced_address = dep::std::hash::pedersen_with_separator([x, y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n        assert(reproduced_address == context.this_address());\n\n        // Execute calls\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Constructs the contract\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Return private circuit public inputs. All private functions need to return this as it is part of the input of the private kernel.\n        PrivateContext::new(inputs, 0).finish()\n    }\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-contracts/src/contracts/schnorr_single_key_account_contract/src/main"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
}
