{
  "name": "SchnorrAccount",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "signing_pub_key_x",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        {
          "name": "signing_pub_key_y",
          "type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
<<<<<<< HEAD
  ]
=======
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "mod storage;\nmod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\ncontract SchnorrAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::private_call_stack_item::PrivateCallStackItem;\n    use dep::aztec::public_call_stack_item::PublicCallStackItem;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::get_public_key::get_public_key;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::note::utils as note_utils;\n    use dep::aztec::note::note_header::NoteHeader;\n    use dep::aztec::constants_gen::MAX_NOTE_FIELDS_LENGTH;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    use crate::storage::Storage;\n    use crate::public_key_note::PublicKeyNote;\n    use crate::public_key_note::PublicKeyNoteMethods;\n    use crate::public_key_note::PUBLIC_KEY_NOTE_LEN;\n\n    // docs:start:entrypoint\n\n    fn entrypoint(\n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        signature: pub [u8;64], // schnorr signature of the payload hash\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        // Initialize context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64\n        let mut args: BoundedVec<Field, 77> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in signature { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Load public key from storage\n        let storage = Storage::init();\n        let public_key = storage.signing_public_key.get_note(&mut context);\n\n        // Verify payload signature\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n\n        // Verify signature of the payload bytes\n        let verification = std::schnorr::verify_signature(public_key.x, public_key.y, signature, message_bytes);\n        assert(verification == true);\n\n        // docs:end:entrypoint\n\n        // Execute calls\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Constructs the contract\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n        signing_pub_key_x: pub Field,\n        signing_pub_key_y: pub Field,\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        let storage = Storage::init();\n        \n        let mut context = PrivateContext::new(inputs, abi::hash_args([signing_pub_key_x, signing_pub_key_y]));\n        \n        let this = context.this_address();\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.signing_public_key.initialise(&mut context, &mut pub_key_note);\n        \n        emit_encrypted_log(\n            &mut context,\n            this,\n            storage.signing_public_key.storage_slot,\n            get_public_key(this),\n            pub_key_note.serialise(),\n        );\n\n        context.finish()\n    }\n\n    // Computes notes hash and nullifier.\n    // Note 1: Needs to be defined by every contract producing logs.\n    // Note 2: Having it in all the contracts gives us the ability to compute the note hash and nullifier differently for different kind of notes.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; PUBLIC_KEY_NOTE_LEN]) -> [Field; 4] {\n        assert(storage_slot == 1);\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(PublicKeyNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-contracts/src/contracts/schnorr_account_contract/src/main"
      },
      "3": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "33": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/log"
      },
      "39": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(suyash): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(storage_slot, nullifier, preimage, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/lifecycle"
      },
      "40": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_unique_siloed_note_hash,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::messaging::get_commitment_getter_data::make_commitment_getter_data;\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn ensure_note_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    let saved_note = get_note_internal(storage_slot, note_interface);\n\n    // Only copy over the header to the original note to make sure the preimage is the same.\n    let get_header = note_interface.get_header;\n    let set_header = note_interface.set_header;\n    let note_header = get_header(saved_note);\n    set_header(note, note_header);\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, *note);\n    context.push_read_request(note_hash_for_read_request);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\n// Modifies the note by populating it with header info.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    // Initialize header of note. Must be done before computing note hashes as it initializes the:\n    // - storage slot (used in inner note hash)\n    // - the contract address (used in siloed note hash)\n    // - and the nonce (used in the unique siloed note hash)\n    let set_header = note_interface.set_header;\n    let note_header = NoteHeader {\n        contract_address: (*context).this_address(),\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n        // real nonce (once public kernel applies nonces).\n        nonce: 0,\n        storage_slot\n    };\n    set_header(note, note_header);\n\n    // Get a note from oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let raw_oracle_ret = oracle::get_commitment::get_commitment(inner_note_hash);\n    let deserialized_oracle_ret = make_commitment_getter_data(raw_oracle_ret, 0);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // unique_siloed_note_hash once public kernel applies nonces\n    let saved_siloed_note_hash = deserialized_oracle_ret.message;\n\n    assert(saved_siloed_note_hash != 0); // TODO(dbanks12): necessary?\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    // Ensure that the note hash retrieved from oracle matches the one computed from note.\n    let computed_siloed_note_hash = compute_siloed_note_hash(note_interface, *note);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // compute_note_hash_for_read_or_nullify once public kernel applies nonces\n    assert(computed_siloed_note_hash == saved_siloed_note_hash);\n\n    context.push_read_request(computed_siloed_note_hash);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        let mut note_hash_for_read_request = 0;\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n            note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n        };\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n        // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n        context.push_read_request(note_hash_for_read_request);\n    };\n\n    // TODO(#1660)\n    // Move it back to get_notes_internal and only make read request for selected notes.\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/note_getter"
      },
      "42": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/note_hash"
      },
      "46": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    let mut note = deserialise(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/note/utils"
      },
      "48": {
        "source": "use dep::std::hash::pedersen_with_separator;\nuse crate::context::PrivateContext;\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle;\nuse crate::constants_gen::{\n    GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n    EMPTY_NULLIFIED_COMMITMENT,\n};\n\nstruct ImmutableSingleton<Note, N> {\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    fn new(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Self {\n        ImmutableSingleton { storage_slot, note_interface }\n    }\n\n    unconstrained fn is_initialised(self) -> bool {\n        let nullifier = self.compute_initialisation_nullifier();\n        oracle::notes::is_nullifier_emitted(nullifier)\n    }\n\n    fn initialise(self, context: &mut PrivateContext, note: &mut Note) {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialisation_nullifier();\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n\n    fn compute_initialisation_nullifier(self) -> Field {\n        pedersen_with_separator([self.storage_slot], GENERATOR_INDEX__INITIALISATION_NULLIFIER)[0]\n    }\n    \n    fn get_note(self, context: &mut PrivateContext) -> Note {\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n\n    unconstrained fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/state_vars/immutable_singleton"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "70": {
        "source": "use crate::types::point::Point;\nuse dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_public_key"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/lasse/aztec3-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
>>>>>>> feat: initial uniswap skeleton
}
