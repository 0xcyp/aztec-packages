#include <gtest/gtest.h>

#include "barretenberg/crypto/pedersen_commitment/pedersen.hpp"
#include "barretenberg/ecc/curves/grumpkin/grumpkin.hpp"
#include "barretenberg/proof_system/circuit_builder/ultra_circuit_builder.hpp"
#include "barretenberg/stdlib/primitives/point/point.hpp"
#include "schnorr.hpp"

namespace proof_system::test_stdlib_schnorr {

using namespace barretenberg;
using namespace proof_system::plonk::stdlib;
using namespace proof_system::plonk::stdlib::schnorr;

using Composer = proof_system::UltraCircuitBuilder;
using bool_ct = bool_t<Composer>;
using byte_array_ct = byte_array<Composer>;
using field_ct = field_t<Composer>;
using point_ct = point<Composer>;
using witness_ct = witness_t<Composer>;

/**
 * @test Test circuit verifying a Schnorr signature generated by \see{crypto::schnorr::verify_signature}.
 * We only test: messages signed and verified using Grumpkin and the BLAKE2s hash function. We only test
 * TurboPLONK. We test strings of lengths 0, 1, ..., 33.
 */
TEST(stdlib_schnorr, verify_signature)
{
    std::string longer_string = "This is a test string of length 34";

    std::vector<size_t> test_lengths({ 0, 1, 32, 33 });
    for (size_t i : test_lengths) {
        Composer composer = Composer();
        auto message_string = longer_string.substr(0, i);

        crypto::schnorr::key_pair<grumpkin::fr, grumpkin::g1> account;
        account.private_key = grumpkin::fr::random_element();
        account.public_key = grumpkin::g1::one * account.private_key;

        crypto::schnorr::signature signature =
            crypto::schnorr::construct_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(
                message_string, account);

        bool first_result = crypto::schnorr::verify_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(
            message_string, account.public_key, signature);
        EXPECT_EQ(first_result, true);

        point_ct pub_key{ witness_ct(&composer, account.public_key.x), witness_ct(&composer, account.public_key.y) };
        signature_bits sig = convert_signature(&composer, signature);
        byte_array_ct message(&composer, message_string);
        verify_signature(message, pub_key, sig);

        info("composer gates = ", composer.get_num_gates());
        bool result = composer.check_circuit();
        EXPECT_EQ(result, true);
    }
}

/**
 * @brief Verification fails when the wrong public key is used.
 *
 */
TEST(stdlib_schnorr, verify_signature_failure)
{
    Composer composer = Composer();
    std::string message_string = "This is a test string of length 34";

    // create key pair 1
    crypto::schnorr::key_pair<grumpkin::fr, grumpkin::g1> account1;
    account1.private_key = grumpkin::fr::random_element();
    account1.public_key = grumpkin::g1::one * account1.private_key;

    // create key pair 2
    crypto::schnorr::key_pair<grumpkin::fr, grumpkin::g1> account2;
    account2.private_key = grumpkin::fr::random_element();
    account2.public_key = grumpkin::g1::one * account2.private_key;

    // sign the message with account 1 private key
    crypto::schnorr::signature signature =
        crypto::schnorr::construct_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(message_string,
                                                                                                      account1);

    // check native verification with account 2 public key fails
    bool native_result = crypto::schnorr::verify_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(
        message_string, account2.public_key, signature);
    EXPECT_EQ(native_result, false);

    // check stdlib verification with account 2 public key fails
    point_ct pub_key2_ct{ witness_ct(&composer, account2.public_key.x), witness_ct(&composer, account2.public_key.y) };
    signature_bits sig = convert_signature(&composer, signature);
    byte_array_ct message(&composer, message_string);
    verify_signature(message, pub_key2_ct, sig);

    info("composer gates = ", composer.get_num_gates());

    bool verification_result = composer.check_circuit();
    EXPECT_EQ(verification_result, false);
}

/**
 * @test Like stdlib_schnorr.verify_signature, but we use the function signature_verification that produces a
 * boolean witness and does not require the prover to provide a valid signature.
 */
TEST(stdlib_schnorr, signature_verification_result)
{
    std::string longer_string = "This is a test string of length 34";

    Composer composer = Composer();

    crypto::schnorr::key_pair<grumpkin::fr, grumpkin::g1> account;
    account.private_key = grumpkin::fr::random_element();
    account.public_key = grumpkin::g1::one * account.private_key;

    crypto::schnorr::signature signature =
        crypto::schnorr::construct_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(longer_string,
                                                                                                      account);

    bool first_result = crypto::schnorr::verify_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(
        longer_string, account.public_key, signature);
    EXPECT_EQ(first_result, true);

    point_ct pub_key{ witness_ct(&composer, account.public_key.x), witness_ct(&composer, account.public_key.y) };
    signature_bits sig = convert_signature(&composer, signature);
    byte_array_ct message(&composer, longer_string);
    bool_ct signature_result = signature_verification_result(message, pub_key, sig);
    EXPECT_EQ(signature_result.witness_bool, true);

    info("composer gates = ", composer.get_num_gates());

    bool result = composer.check_circuit();
    EXPECT_EQ(result, true);
}

/**
 * @test Like stdlib_schnorr.verify_signature_failure, but we use the function signature_verification that produces a
 * boolean witness and allow for proving that a signature verification fails.
 */
TEST(stdlib_schnorr, signature_verification_result_failure)
{
    Composer composer = Composer();
    std::string message_string = "This is a test string of length 34";

    // create key pair 1
    crypto::schnorr::key_pair<grumpkin::fr, grumpkin::g1> account1;
    account1.private_key = grumpkin::fr::random_element();
    account1.public_key = grumpkin::g1::one * account1.private_key;

    // create key pair 2
    crypto::schnorr::key_pair<grumpkin::fr, grumpkin::g1> account2;
    account2.private_key = grumpkin::fr::random_element();
    account2.public_key = grumpkin::g1::one * account2.private_key;

    // sign the message with account 1 private key
    crypto::schnorr::signature signature =
        crypto::schnorr::construct_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(message_string,
                                                                                                      account1);

    // check native verification with account 2 public key fails
    bool native_result = crypto::schnorr::verify_signature<Blake2sHasher, grumpkin::fq, grumpkin::fr, grumpkin::g1>(
        message_string, account2.public_key, signature);
    EXPECT_EQ(native_result, false);

    // check stdlib verification with account 2 public key fails
    point_ct pub_key2_ct{ witness_ct(&composer, account2.public_key.x), witness_ct(&composer, account2.public_key.y) };
    signature_bits sig = convert_signature(&composer, signature);
    byte_array_ct message(&composer, message_string);
    bool_ct signature_result = signature_verification_result(message, pub_key2_ct, sig);
    EXPECT_EQ(signature_result.witness_bool, false);

    info("composer gates = ", composer.get_num_gates());

    bool verification_result = composer.check_circuit();
    EXPECT_EQ(verification_result, true);
}

} // namespace proof_system::test_stdlib_schnorr
